// aho_corasick.cpp : Defines the entry point for the application.
//

#include "aho_corasick.hpp"
#include "Parser.h"
#include "Statistics.h"
#include "ExactMatches.h"
#include <nlohmann/json.hpp>
#include <iostream>
#include <string>
#include <fstream>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <unistd.h>		// comment when running from Visual Studio
#include <chrono>

/// <summary>
/// Parse text to find exact matches in the Aho Corasick TRIE.
/// Prints any exact matches found.
/// </summary>
/// <param name="trie">The Aho Corasick State Machine (TRIE tree)</param>
/// <param name="text">The input text to parse</param>
void find(aho_corasick::trie& trie, std::basic_string<char>& text) {
	auto res = trie.parse_text(text);
	std::cout << "Parsed [" << res.size() << "] item(s): " << std::endl;
	for (auto match : res) { // res is of class emit
		std::cout << '\t' << match.get_keyword() << std::endl;
	}
	std::cout << std::endl;
}


/// <summary>
/// Run a single test of insertion to the Aho Corasick TRIE tree for a given min threshold on the exact matches.
/// (no need to run more than 1 test because TRIE Theorm ensures that for every random order insertion the TRIE will look the same.
/// </summary>
/// <param name="stats">A class member of Statistics</param>
/// <param name="threshold">Minimum length threshold for the exact matches (take only exact matches with length >= threshold)</param>
/// <param name="bstrings">An std::vector of the basic_string<char> represeting the exact matches to insert</param>
void runTest(Statistics& stats, const size_t threshold, const std::vector<bstring>& bstrings) {
	// Pre test: setting a vector of the min thresholded basic_strings:
	std::vector<bstring> thresholded_bstrings;
	for (auto s : bstrings) {
		if (s.length() >= threshold) {
			thresholded_bstrings.push_back(s);
		}
	}

	aho_corasick::trie* aho_corasick_trie;
	std::size_t nodes_size = 0;
	std::size_t aho_corasick_size = 0;
	std::size_t aho_corasick_no_emits_size = 0;
	std::size_t exact_matches_inserted = 0;

	std::cout << "========================================== Min Threshold <= " << threshold << " Bytes ==========================================" << std::endl;

	// TIME STAMP BEGIN: initiate Aho Corasick state machine
	auto timestamp_a = std::chrono::high_resolution_clock::now();

	// Allocate a new TRIE tree for test timing consistancy
	aho_corasick_trie = new aho_corasick::trie();

	// Insert the exact matches into the aho corasick TRIE
	for (bstring s : thresholded_bstrings) {
		aho_corasick_trie->insert(s);
		exact_matches_inserted++;
	}

	nodes_size = aho_corasick_trie->traverse_tree();
	aho_corasick_size = aho_corasick_trie->traverse_tree(true, true);
	aho_corasick_no_emits_size = aho_corasick_trie->traverse_tree(true, false);

	// Find example:
	// std::basic_string<char> toParse_spc = { 'g', 'A', 't', 'e', 'C', 'r', 'a', 'S', 'H', 'E', 'r' };
	// find(trie, toParse_spc);

	delete aho_corasick_trie;

	// TIME STAMP END: delete aho corasick automaton
	auto timestamp_b = std::chrono::high_resolution_clock::now();
	auto test_runtime = std::chrono::duration_cast<std::chrono::milliseconds>(timestamp_b - timestamp_a).count();

	// Collect and Print Statistics:
	TestStatistics test_data = {
		nodes_size,
		aho_corasick_size,
		aho_corasick_no_emits_size,
		exact_matches_inserted,
		threshold,
		static_cast<double>(test_runtime)
	};
	stats.addData(test_data);

	std::cout << std::endl << std::dec << exact_matches_inserted << " Exact Match(es) were inserted." << std::endl		\
		<< "Aho Corasick TRIE full size: " << aho_corasick_size << std::endl											\
		<< "Aho Corasick TRIE no emits size: " << aho_corasick_no_emits_size << std::endl								\
		<< "Aho Corasick TRIE only nodes size: " << nodes_size << std::endl												\
		<< "Insertion time: " << static_cast<double>(test_runtime) << "[ms]." << std::endl								\
		<< std::endl;
}
	

/// <summary>
/// Parse the .json file, which was generated by the python script in Part A, for ExactMatches.
/// Each ExactMatch includes the extracted sub-exact match from a given rule, the rule type (content / pcre) and relevant line number in the snort file.
/// 1) Parse the file to extract lines
//      line example:
//      //std::string line = "[12, \"pcre\", [[\"0x00\", \"0x00\", \"0x00\", \"0x65\", \"0x63\", \"0x72\", \"0x61\", \"0x73\", \"0x68\", \"0x65\", \"0x00\"], [\"0x73\", \"0x65\", \"0x72\", \"0x76\", \"0x65\", \"0x72\"], [\"0x6f\", \"0x6e\", \"0x2d\", \"0x6c\", \"0x69\", \"0x6e\", \"0x65\", \"0x2e\", \"0x2e\", \"0x2e\"]]]";
// 2) From each line (/rule) extract exact matches
// 3) For each desired L = {2, 4, 8}:
//      A) For each desired G = {1, 2, 4, L}:
//      B) Make 100 trials of inserting RANDOMALLY to the cuckoohash and check throughput
// 4) Store data and plot graphs
/// </summary>
/// <param name="argc"></param>
/// <param name="argv">Run with path to exact_matches_hex.json from terminal/script.</param>
/// <returns></returns>
int main(int argc, char* argv[]) {
	auto start_time = std::chrono::high_resolution_clock::now();
	std::string file_path = "parta_data_by_exactmatch.json";
	std::string dest_path = "";
	
	// Comment this when running in Visual Studio (as well as #include <unistd.h>
	// USE IN WSL WITH THE UNIX STANDARD LIBRARY <UNISTD.H>
	int opt;
	bool is_file_path_set = false;
	while ((opt = getopt(argc, argv, "f:d:")) != -1) {
		switch (opt) {
		case 'f':
			file_path = optarg;
			is_file_path_set = true;
			break;
		case 'd':
			dest_path = optarg;
			break;
		default:
			std::cerr << "Usage: " << argv[0] << " [-f file_path] [-d dest_path]" << std::endl;
			exit(EXIT_FAILURE);
		}
	}

	if (!is_file_path_set) {
		std::cerr << "Usage: " << argv[0] << " [-f file_path] [-d dest_path]" << std::endl;
		exit(EXIT_FAILURE);
	}
	std::cout << "File path: " << file_path << std::endl;

	ExactMatches exact_matches;
	parseFile(file_path, exact_matches);

	std::vector<bstring> bstrings;
	std::size_t max_length = convertExactMatches(exact_matches, bstrings);
	std::size_t max_threshold = max_length + 1;

	Statistics stats;
	for (std::size_t threshold = 1; threshold <= max_threshold; ++threshold) {
		runTest(stats, threshold, bstrings);
	}
	stats.writeToFile(dest_path, "partc_results.json");

	auto end_time = std::chrono::high_resolution_clock::now();
	auto total_runtime = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();
	std::cout << "Finished running Aho Corasick Tests in " << static_cast<double>(total_runtime) << "[ms]." << std::endl;
	// TODO: run valgrind on this, i dont see who deletes after the 'new' allocates by state::add_state().
	return 0;
}
