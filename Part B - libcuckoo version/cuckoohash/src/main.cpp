#include <libcuckoo/cuckoohash_map.hh>
#include <nlohmann/json.hpp>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <set>
#include <algorithm>
#include <random>
#include <chrono>
#include "ExactMatches.h"
#include "Parser.h"
#include "Substring.h"

#define NUMBER_OF_TESTS 100

using json = nlohmann::json;

using Substring64 = Substring<uint64_t>;
using Substring32 = Substring<uint32_t>;
using Substring16 = Substring<uint16_t>;
using Substring8 = Substring<uint8_t>;
using Cuckoo64 = libcuckoo::cuckoohash_map<uint64_t, uint64_t>;
using Cuckoo32 = libcuckoo::cuckoohash_map<uint32_t, uint32_t>;
using Cuckoo16 = libcuckoo::cuckoohash_map<uint16_t, uint16_t>;
using Cuckoo8 = libcuckoo::cuckoohash_map<uint8_t, uint8_t>;

// 1) Parse the file to extract lines
//      line example:
//       //std::string line = "[12, \"pcre\", [[\"0x00\", \"0x00\", \"0x00\", \"0x65\", \"0x63\", \"0x72\", \"0x61\", \"0x73\", \"0x68\", \"0x65\", \"0x00\"], [\"0x73\", \"0x65\", \"0x72\", \"0x76\", \"0x65\", \"0x72\"], [\"0x6f\", \"0x6e\", \"0x2d\", \"0x6c\", \"0x69\", \"0x6e\", \"0x65\", \"0x2e\", \"0x2e\", \"0x2e\"]]]";
// 2) From each line (/rule) extract exact matches
// 3) For each desired L = {2, 4, 8}:
//      A) For each desired G = {1, 2, 4, L}:
//      B) Make 100 trials of inserting RANDOMALLY to the cuckoohash and check throughput
// 4) Store data and plot graphs

template <typename T>
void insertToCuckoo(const std::vector<Substring<T>>& substrings, libcuckoo::cuckoohash_map<T, T>& cuckoo_hash) {
	for (const auto& iter : substrings) {
		cuckoo_hash.insert(iter.substring, 1);
	}
}

int main(int argc, char* argv[]) {
    auto start_time = std::chrono::high_resolution_clock::now();
    std::string file_path = "exact_matches_hex.json";
    if (argc >= 2) { // running from console
        file_path = argv[1];
    }

    // Parse the .json file, which was generated by the python script in Part A, for ExactMatches.
    // Each ExactMatch includes the extracted sub-exact match from a given rule, the rule type (content / pcre) and relevant line number in the snort file.
    ExactMatches exact_matches;
    parseFile(file_path, exact_matches);
    
    // Parse the ExactMatches and extract Substrings of L bytes with parsing of G bytes jump gap per substring.
    std::set<Substring64> substrings;
    for (auto it = exact_matches.exact_matches->begin(); it != exact_matches.exact_matches->end(); ++it) {
        std::string hexString = (*it)->getExactMatch().substr(2);   // clean "0x"
        Substring64::extractSubstrings(hexString, substrings);      // G = default 1, L = default sizeof(T), T here is uint64_t.
    }
    std::cout << std::dec << substrings.size() << " Substring(s) have been produced." << std::endl;
   
    // Create a vector for shuffling the values (we used set for removing doubles, but it cannot be shuffled directly).
    std::vector<Substring64> shuffled_substrings(substrings.begin(), substrings.end());

    // Create cuckoo hash map
    const std::size_t NUMBER_OF_RESERVED_ELEMENTS = substrings.size() / libcuckoo::DEFAULT_SLOT_PER_BUCKET;
    Cuckoo64 cuckoo_hash(NUMBER_OF_RESERVED_ELEMENTS);
    double sum_load_factors = 0;
    
    // Make NUMBER_OF_TESTS=100 random shuffles of the vector, for each, insert to a new cuckoohash and calculate the capacity 
    for (int i = 0; i < NUMBER_OF_TESTS; ++i) {
        
        // Display the shuffled elements (MAKES PROGRAM VERY SLOW, CHECK WAYS TO SPEED UP PRINT IN OPERATOR<<.
        //for (const auto& substring : shuffledSubstrings) {
        //    std::cout << substring << std::endl;
        //}
        std::shuffle(shuffled_substrings.begin(), shuffled_substrings.end(), std::default_random_engine(std::random_device()()));
        insertToCuckoo(shuffled_substrings, cuckoo_hash);
        sum_load_factors += cuckoo_hash.load_factor();
        std::cout << "The load factor of the hash is: " << cuckoo_hash.load_factor() << std::endl;
        cuckoo_hash.clear();
    }

    // TODO: check why load factor stays the same. (also if changing NUMBER_OF_RESERVED_ELEMENTS to a random LOW number like 256).
    std::cout << "Average load factor is: " << sum_load_factors / NUMBER_OF_TESTS << ". Calculated of " << NUMBER_OF_TESTS \
        << " run(s) of cuckoo hash insertions with L = " << sizeof(Substring64) << " and G = " << _SUBSTRING_DEFAULT_GAP << "." << std::endl;

    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    std::cout << "Execution time recorded: " << duration.count() << " [ms]." << std::endl;
    
    return 0;
}